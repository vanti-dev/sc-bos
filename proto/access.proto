syntax = "proto3";

package smartcore.bos;

option go_package = "github.com/smart-core-os/sc-bos/pkg/gen";

import "google/protobuf/field_mask.proto";
import "google/protobuf/timestamp.proto";
import "actor.proto";

// AccessApi describes the capability to manage access to a resource.
// This could be a access card reader next to a door, or a barrier at a car park.
service AccessApi {
  rpc GetLastAccessAttempt(GetLastAccessAttemptRequest) returns (AccessAttempt) {}
  rpc PullAccessAttempts(PullAccessAttemptsRequest) returns (stream PullAccessAttemptsResponse) {}

  rpc CreateAccessGrant(CreateAccessGrantRequest) returns (AccessGrant) {}
  rpc UpdateAccessGrant(UpdateAccessGrantRequest) returns (AccessGrant) {}
  rpc DeleteAccessGrant(DeleteAccessGrantRequest) returns (DeleteAccessGrantResponse) {}
  rpc GetAccessGrant(GetAccessGrantsRequest) returns (AccessGrant) {}
  rpc ListAccessGrants(ListAccessGrantsRequest) returns (ListAccessGrantsResponse) {}

  // todo: rpc CreateActor... to replace axiomxa service
  // todo: rpc GrantAccess for manually granting access to an actor
}

message AccessAttempt {
  enum Grant {
    // The status of the access attempt is unknown.
    GRANT_UNKNOWN = 0;
    // The access attempt was granted.
    GRANTED = 1;
    // The access attempt was denied.
    DENIED = 2;
    // Access is pending a decision.
    PENDING = 3;
    // Access was aborted before being granted or denied.
    // Typically only used following PENDING.
    ABORTED = 4;
    // Access was not granted, happened anyway.
    // For example if someone forced the door open.
    FORCED = 5;
    // Access was granted, but failed for other reasons.
    // For example if the door is stuck
    FAILED = 6;
    // Access was granted, but to the actor before this one.
    // Happens when someone follows another person through a door.
    TAILGATE = 7;
  }
  // Was the access attempt granted or denied.
  Grant grant = 1;
  // A reason for either granting or denying the access attempt.
  // For example "Operator override" or "Unrecognised card".
  string reason = 2;
  // Actor describes the entity attempting to gain access.
  // Optional.
  Actor actor = 3;

  // The time the access attempt was made
  google.protobuf.Timestamp access_attempt_time = 4;
}

message GetLastAccessAttemptRequest {
  // The name of the device to get the last access attempt for.
  string name = 1;
  google.protobuf.FieldMask read_mask = 2;
}

message PullAccessAttemptsRequest {
  // The name of the device to pull access attempts for.
  string name = 1;
  google.protobuf.FieldMask read_mask = 2;
  bool updates_only = 3;
}

message PullAccessAttemptsResponse {
  repeated Change changes = 1;

  message Change {
    string name = 1;
    google.protobuf.Timestamp change_time = 2;
    AccessAttempt access_attempt = 3;
  }
}

// AccessGrant represents an Actor granting access to a space or resource for a delimited time to another Actor.
// The access is enabled through an entry_code and/or qr_code that the grantee can use on the Access Control device to enter a protected space or use a protected resource.
message AccessGrant {
  // id is a unique identifier for the AccessGrant native to the subsystem device.
  string id = 1;
  // start_time is the time from which the AccessGrant is valid.
  google.protobuf.Timestamp start_time = 2;
  // end_time is the time in which the AccessGrant is revoked.
  google.protobuf.Timestamp end_time = 3;
  // purpose describes the reason for the AccessGrant.
  // For example: Business, Training, Visit, Meeting, Maintenance, Emergency, Other, etc.
  optional string purpose = 4;
  // grantee is the actor that has been granted access.
  Actor grantee = 5;
  // granter is the actor that granted the AccessGrant or is expecting the grantee
  // For example: Front of House (FoH) security, FoH host, FoH receptionist, interviewer, etc.
  Actor granter = 6;
  // created_time is the time the AccessGrant was created.
  // Since AccessGrants are synchronized between external 3rd party systems and Access Control devices
  // and there is no guarantee that Access Control devices always support or store created_time persistently,
  // the client creating the AccessGrant should set created_time on creation.
  // SmartCore implementations should not overwrite created_time if it is already set,
  // and respect the value if storing AccessGrants persistently.
  optional google.protobuf.Timestamp created_time = 7;
  // updated_time is the time the AccessGrant was last updated.
  // Since AccessGrants are synchronized between external 3rd party systems and Access Control devices
  // and there is no guarantee that Access Control devices always support or store updated_time persistently,
  // the client updating the AccessGrant should set updated_time.
  // SmartCore implementations should not overwrite updated_time if it is already set,
  // and respect the value if updating AccessGrants in persistent storage.
  optional google.protobuf.Timestamp updated_time = 8;

  // entry_code is a code the grantee can use to enter the protected area.
  // This should be automatically generated by the Access Control device or SmartCore if not supported.
  // The client only need receive AccessGrants with entry_code already set, and not set it themselves.
  optional string entry_code = 9;
  // qr_code is a QR code the grantee can scan to enter the protected area
  // Can be one of a URL to the QR code image, or image data where the PNG image format is preferred.
  // This should be automatically generated by the Access Control device or SmartCore if not supported.
  // The client only need receive AccessGrants with qr_code already set, and not set it themselves.
  oneof qr_code {
    string qr_code_url = 10;
    bytes qr_code_image = 11;
  }
  // skip_check_in indicates whether the grantee should physically check in with granter
  // before they enter the protected area or skip the check-in process regardless of the use of entry_code or qr_code.
  // For example, a delivery person may be granted access to a building for a short period of time
  // but should still be required to check in with the front desk receptionist.
  optional bool skip_check_in = 12;
}
message CreateAccessGrantRequest {
  // The name of the device to create AccessGrant for.
  string name = 1;
  // The AccessGrant to create.
  AccessGrant access_grant = 2;
}


message UpdateAccessGrantRequest {
  // The name of the device to update AccessGrant for.
  string name = 1;
  // the AccessGrant to update.
  // The id of the AccessGrant to update should be set.
  // All other fields will be overwritten by the values in this request message.
  AccessGrant access_grant = 2;
}

message DeleteAccessGrantRequest {
  // The name of the device to delete AccessGrant for.
  string name = 1;
  // The id of the AccessGrant to delete.
  string access_grant_id = 2;
}

message DeleteAccessGrantResponse {}

message GetAccessGrantsRequest {
  // The name of the device to get AccessGrant for.
  string name = 1;
  // The id of the AccessGrant to get.
  string access_grant_id = 2;
  google.protobuf.FieldMask read_mask = 3;
}

message ListAccessGrantsRequest {
  // The name of the device to list AccessGrants for.
  string name = 1;
  google.protobuf.FieldMask read_mask = 2;
  // The maximum number of AccessGrants to return.
  // The service may return fewer than this value.
  // If unspecified, at most 50 items will be returned.
  // The maximum value is 1000; values above 1000 will be coerced to 1000.
  int32 page_size = 3;
  // A page token, received from a previous `ListAccessGrantsResponse` call.
  // Provide this to retrieve the subsequent page.
  string page_token = 4;
}

message ListAccessGrantsResponse {
  repeated AccessGrant access_grants = 1;
  // A token, which can be sent as `page_token` to retrieve the next page.
  // If this field is omitted, there are no subsequent pages.
  string next_page_token = 2;
  // If non-zero this is the total number of AccessGrants after filtering is applied.
  // This may be an estimate.
  int32 total_size = 3;
}