package pgxtenants

import (
	"context"
	"time"

	"github.com/jackc/pgx/v4"
	"github.com/pborman/uuid"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/known/timestamppb"

	"github.com/smart-core-os/sc-bos/pkg/gen"
)

// ValidateTenantID checks if the given tenant ID is a valid ID for a tenant stored by pgxtenants.
func ValidateTenantID(id string) bool {
	return uuid.Parse(id) != nil
}

// CreateTenant registers a new tenant in the database. The tenant has an autogenerated ID.
// The new tenant has no zones assigned.
func CreateTenant(ctx context.Context, tx pgx.Tx, title string) (*gen.Tenant, error) {
	// language=postgresql
	query := `
		INSERT INTO tenant (id, title, create_time) VALUES (DEFAULT, $1, $2) RETURNING id;
	`

	tenant := &gen.Tenant{
		Title:      title,
		CreateTime: timestamppb.Now(),
	}
	row := tx.QueryRow(ctx, query, tenant.Title, tenant.CreateTime.AsTime())
	err := row.Scan(&tenant.Id)
	if err != nil {
		return nil, err
	}
	return tenant, nil
}

func GetTenant(ctx context.Context, tx pgx.Tx, id string) (*gen.Tenant, error) {
	// language=postgresql
	query := `
		SELECT title, create_time FROM tenant WHERE id = $1;
    `

	tenant := &gen.Tenant{Id: id}
	row := tx.QueryRow(ctx, query, id)
	var createTime time.Time
	err := row.Scan(&tenant.Title, &createTime)
	tenant.CreateTime = timestamppb.New(createTime)
	if err != nil {
		return nil, err
	}

	// obtain list of assigned zones
	// language=postgresql
	query = `
		SELECT zone_name FROM tenant_zone WHERE tenant = $1;
    `
	rows, err := tx.Query(ctx, query, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	for rows.Next() {
		var zone string
		err = rows.Scan(&zone)
		if err != nil {
			return nil, err
		}
		tenant.ZoneNames = append(tenant.ZoneNames, zone)
	}
	return tenant, nil
}

func ListTenants(ctx context.Context, tx pgx.Tx) ([]*gen.Tenant, error) {
	// language=postgresql
	query := `
		SELECT t.id, t.title, t.create_time, array(
		   	SELECT z.zone_name FROM tenant_zone z
		    WHERE z.tenant = t.id
		    ORDER BY z.zone_name
		) AS zone_names FROM tenant t
		ORDER BY t.create_time;
	`

	rows, err := tx.Query(ctx, query)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var tenants []*gen.Tenant
	for rows.Next() {
		tenant := &gen.Tenant{}
		var createTime time.Time
		err = rows.Scan(&tenant.Id, &tenant.Title, &createTime, &tenant.ZoneNames)
		if err != nil {
			return nil, err
		}
		tenant.CreateTime = timestamppb.New(createTime)
		tenants = append(tenants, tenant)
	}
	return tenants, nil
}

func UpdateTenantTitle(ctx context.Context, tx pgx.Tx, id string, title string) error {
	// language=postgresql
	query := `
		UPDATE tenant
		SET title = $1
		WHERE id = $2;
    `
	tag, err := tx.Exec(ctx, query, title, id)
	if err != nil {
		return err
	}
	if tag.RowsAffected() == 0 {
		return pgx.ErrNoRows
	}
	return nil
}

func DeleteTenant(ctx context.Context, tx pgx.Tx, id string) error {
	// language=postgresql
	query := `
		DELETE FROM tenant WHERE id = $1;
    `

	tag, err := tx.Exec(ctx, query, id)
	if err != nil {
		return err
	}
	if tag.RowsAffected() == 0 {
		return pgx.ErrNoRows
	}
	return nil
}

// AddTenantZones will store an association between the given tenant and a set of zones.
// Will fail if the tenant doesn't exist.
func AddTenantZones(ctx context.Context, tx pgx.Tx, tenantID string, zones []string) error {
	cols := []string{"tenant", "zone_name"}
	var rows [][]any
	for _, zoneID := range zones {
		// CopyFrom doesn't do automatic UUID/string conversion for us
		id := uuid.Parse(tenantID)
		rows = append(rows, []any{id, zoneID})
	}
	_, err := tx.CopyFrom(ctx, pgx.Identifier{"tenant_zone"}, cols, pgx.CopyFromRows(rows))
	return err
}

func RemoveTenantZones(ctx context.Context, tx pgx.Tx, tenantID string, zones []string) error {
	// language=postgresql
	query := `
		DELETE FROM tenant_zone
		WHERE tenant = $1 AND zone_name = $2;
	`

	batch := &pgx.Batch{}
	for _, zone := range zones {
		batch.Queue(query, tenantID, zone)
	}

	br := tx.SendBatch(ctx, batch)
	defer func() {
		_ = br.Close()
	}()
	for i := 0; i < batch.Len(); i++ {
		_, err := br.Exec()
		if err != nil {
			return err
		}
	}
	return br.Close()
}

func ReplaceTenantZones(ctx context.Context, tx pgx.Tx, tenantID string, zones []string) error {
	// language=postgresql
	query := `DELETE FROM tenant_zone WHERE tenant = $1;`
	_, err := tx.Exec(ctx, query, tenantID)
	if err != nil {
		return err
	}

	return AddTenantZones(ctx, tx, tenantID, zones)
}

// CreateTenantSecret adds a tenant secret to the database.
// Only the fields TenantID, Name, SecretHash and Expires will be used from secret.
// Returns the newly created tenant secret row.
func CreateTenantSecret(ctx context.Context, tx pgx.Tx, secret *gen.Secret) (*gen.Secret, error) {
	secret = proto.Clone(secret).(*gen.Secret)

	// language=postgresql
	query := `
		INSERT INTO tenant_secret (id, tenant, secret_hash, note, expire_time) VALUES (DEFAULT, $1, $2, $3, $4)
		RETURNING id, create_time;
    `

	var expireTime *time.Time
	if secret.ExpireTime != nil {
		t := secret.ExpireTime.AsTime()
		expireTime = &t
	}
	row := tx.QueryRow(ctx, query, secret.Tenant.GetId(), secret.SecretHash, secret.Note, expireTime)
	var createTime time.Time
	err := row.Scan(&secret.Id, &createTime)
	if err != nil {
		return nil, nil
	}
	secret.CreateTime = timestamppb.New(createTime)
	return secret, nil
}

// GetTenantSecret returns a gen.Secret by secret id.
func GetTenantSecret(ctx context.Context, tx pgx.Tx, id string) (*gen.Secret, error) {
	// language=postgresql
	query := `
		SELECT s.id, s.tenant, t.title, s.secret_hash, s.note, s.create_time, s.expire_time, s.first_use_time, s.last_use_time
		FROM tenant_secret s
			INNER JOIN tenant t on s.tenant = t.id
		WHERE s.id = $1;
    `

	row := tx.QueryRow(ctx, query, id)
	secret := &gen.Secret{}
	err := scanTenantSecret(row, secret)
	if err != nil {
		return nil, err
	}
	return secret, nil
}

// ListTenantSecrets returns all tenant secrets stored in the database.
// If tenantID is non-empty, then only secrets associated with that tenant will be returned. If tenantID is empty
// then secrets from all tenants are returned.
func ListTenantSecrets(ctx context.Context, tx pgx.Tx, tenantID string) ([]*gen.Secret, error) {
	// language=postgresql
	query := `
		SELECT s.id, s.tenant, t.title, s.secret_hash, s.note, s.create_time, s.expire_time, s.first_use_time, s.last_use_time
		FROM tenant_secret s
			INNER JOIN tenant t on s.tenant = t.id
		WHERE $1 = '' OR s.tenant = $1::UUID;
    `

	rows, err := tx.Query(ctx, query, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var secrets []*gen.Secret
	for rows.Next() {
		secret := &gen.Secret{}
		err = scanTenantSecret(rows, secret)
		if err != nil {
			return nil, err
		}
		secrets = append(secrets, secret)
	}
	return secrets, nil
}

// reads out a secret from a DB row, in this order (tenant_secret s, tenant t):
// s.id, s.tenant, t.title, s.secret_hash, s.note, s.create_time, s.expire_time, s.first_use_time, s.last_use_time
func scanTenantSecret(row pgx.Row, secret *gen.Secret) error {
	if secret.Tenant == nil {
		secret.Tenant = &gen.Tenant{}
	}
	var (
		createTime, expireTime, firstUseTime, lastUseTime *time.Time
	)
	err := row.Scan(&secret.Id, &secret.Tenant.Id, &secret.Tenant.Title, &secret.SecretHash, &secret.Note, &createTime,
		&expireTime, &firstUseTime, &lastUseTime)
	if err != nil {
		return err
	}
	secret.CreateTime = nullableTimestamp(createTime)
	secret.ExpireTime = nullableTimestamp(expireTime)
	secret.FirstUseTime = nullableTimestamp(firstUseTime)
	secret.LastUseTime = nullableTimestamp(lastUseTime)
	return nil
}

func DeleteTenantSecret(ctx context.Context, tx pgx.Tx, secretID string) error {
	// language=postgresql
	query := `
		DELETE FROM tenant_secret
		WHERE id = $1;
    `

	tag, err := tx.Exec(ctx, query, secretID)
	if err != nil {
		return err
	}
	if tag.RowsAffected() == 0 {
		return pgx.ErrNoRows
	}
	return nil
}

func nullableTimestamp(t *time.Time) *timestamppb.Timestamp {
	if t == nil {
		return nil
	}
	return timestamppb.New(*t)
}
